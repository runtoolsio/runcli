import argparse
import textwrap

import sys
from rich_argparse import RichHelpFormatter
from rich_argparse.contrib import ParagraphRichHelpFormatter

from runtools.runcore.run import TerminationStatus
from runtools.runcore.util.dt import parse_duration_to_sec
from . import __version__

ACTION_JOB = 'job'
ACTION_SERVICE = 'service'
ACTION_CLEAN = 'clean'
ACTION_CONFIG = 'config'
ACTION_CONFIG_PRINT = 'print'
ACTION_CONFIG_CREATE = 'create'


def parse_args(args):
    parser = argparse.ArgumentParser(
        prog='run',
        description='Run managed job or service',
        formatter_class=RichHelpFormatter)
    parser.add_argument(
        "-V",
        "--version",
        action='version',
        help="Show version of this app and exit",
        version=__version__.__version__)

    parent = init_cfg_parent_parser()
    subparser = parser.add_subparsers(dest='action')  # command/action

    _init_config_parser(subparser)
    _init_job_parser(parent, subparser)
    _init_clean_parser(parent, subparser)

    parsed = parser.parse_args(args)
    if not getattr(parsed, 'action'):
        parser.print_help()
        sys.exit(1)

    if parsed.action == ACTION_JOB:
        _check_conditions(parser, parsed)
    return parsed


def init_cfg_parent_parser():
    """
    Return:
        Parent parser for subparsers to share common configuration options
    """
    parser = argparse.ArgumentParser()
    cfg_group = parser.add_argument_group("Configuration options")
    cfg_group.description = """
        These options control how configuration is loaded. By default, runtools  searches for its configuration file 
        in standard XDG directories and loads settings from the first found file. If no config is found 
        then default one is used. These options allow you to modify this default behavior.
    """
    cfg_group.add_argument('-D', '--def-config', action='store_true',
                           help='Do not lookup config file and use default configuration instead.')
    cfg_group.add_argument('-R', '--config-required', action='store_true',
                           help='Configuration file must be found, otherwise the command will fail. (No fallback)')
    cfg_group.add_argument('-C', '--config', type=str,
                           help="Specifies path to config file stored in custom location. Fails if the file doesn't exist.")
    cfg_group.add_argument('--set', type=str, action='append',
                           help='Override value of config attribute. Format: attribute=value. Example: log.stdout.level=info')
    return parser

def _init_job_parser(parent, subparser):
    """
    Creates parser for `job` command with options organized in logical groups.

    Args:
        parent: parent parser (config options)
        subparser: sub-parser for job parser to be added to
    """
    job_parser = subparser.add_parser(
        ACTION_JOB,
        parents=[parent],
        description='Execute managed batch or long-running job',
        help='Execute managed batch or long-running job',
        formatter_class=ParagraphRichHelpFormatter,
        add_help=False)

    job_parser.description = textwrap.dedent("""
        Run job managed by runtools. Example of execution: run job --id my_job ./my_job.sh arg1 arg2

        It is recommended to use the `--id` option to specify the ID of the job otherwise the ID is constructed from the 
        command and its arguments. 
        
        All time durations (--timeout, --time-warn, etc.) can be specified as a number followed by 
        an optional unit: s(seconds), m(minutes), h(hours), or d(days). If no unit is specified, seconds are assumed.
        """)

    # Environment option
    job_parser.add_argument('-e', '--env', type=str,
                            help="Environment ID where job will run. Uses default from config if not specified.")

    # Identification & Metadata group
    id_group = job_parser.add_argument_group("Identification & Metadata")
    id_group.add_argument('-j', '--id', type=str, metavar='JOB_ID',
                          help='Job ID. Identifies task type. Default: derived from command. '
                               'Recommended to set explicitly.')
    id_group.add_argument('-r', '--run-id', type=str,
                          help='Run ID. Identifies individual executions. Duplicates within same job are not allowed. '
                               'Common values: UUID, date (2025-04-25), time, batch identifier (batch1), etc. '
                               'Default: Autogenerated ID.')
    id_group.add_argument('--param', type=lambda p: p.split('='), action='append',
                          help="Parameters are specified in `name=value` format. They represent metadata of the "
                               "job instance and have no effect on the job execution.")

    # Output Options group
    output_group = job_parser.add_argument_group("Output Options")
    output_group.add_argument('-b', '--bypass-output', action='store_true',
                              help='Disable output capturing. Program output goes directly to stdout/stderr. '
                                   'Improves compatibility with interactive programs using terminal control codes. '
                                   'Note: Disables output-based features like parsing and tracking.')
    output_group.add_argument('-l', '--log-output', action='store_true',
                              help='Save job output to log file. Default location (unless configured otherwise): '
                                   '~/.local/state/runtools/{env}/output/{job_id}/{run_id}.log')
    output_group.add_argument('--log-path', type=str, metavar='PATH',
                              help='Custom path for job output log file. Implies --log-output.')
    output_group.add_argument('--run-log', type=str, metavar='PATH',
                              help='Path where job writes its own log file for this run. Tracking this '
                                   'location enables reading output through commands like `run output`.')
    output_group.add_argument('--output-warn', type=str, metavar='REGEX', action='append', default=[],
                              help='This enables output warning which is triggered each time an output line of the job '
                                   'matches regex specified by the value of this option. For example `--warn-output '
                                   '"ERR*"` triggers output warning each time an output line contains a word starting '
                                   'with ERR.')

    # Status Tracking group
    status_group = job_parser.add_argument_group("Status Tracking")
    status_group.add_argument('-k', '--kv-filter', action='store_true', default=False,
                              help='Key-value output parser is used for task tracking.')
    status_group.add_argument('--kv-alias', type=str, action='append', default=[],
                              help='Mapping of output keys to common fields.')
    status_group.add_argument('-p', '--grok-pattern', type=str, action='append', default=[],
                              help='Grok pattern for extracting fields from output used for task tracking.')

    # Timeout Control group
    timeout_group = job_parser.add_argument_group("Timeout Control")
    timeout_group.add_argument('-t', '--timeout', type=_duration_type, metavar='DURATION',
                               help='Time after which the job will be stopped with `TIMEOUT` status.')
    timeout_group.add_argument('--timeout-sig', type=str,
                               help='Signal number or code for external stopping the job due to timeout. \n'
                                    'Example 5 sec usage: `timeout --signal=SIGUSR1 5 run job --timeout-sig SIGUSR1 sleep 30`')
    timeout_group.add_argument('--time-warn', type=_duration_type, metavar='DURATION',
                               help='Trigger warning when job runs longer than specified time.')

    # Coordination group
    coord_group = job_parser.add_argument_group("Coordination")
    coord_group.add_argument('-a', '--approve', metavar='PHASE_ID',
                             help='Adds approval phase with specified ID. Job waits in pending state until explicitly '
                                  'approved via API or CLI. ID is used to reference the approval for release commands.')
    # Future options like --depends-on, --wait-for, etc. would go here

    # Concurrency Management group
    concurrency_group = job_parser.add_argument_group("Concurrency Management")
    concurrency_group.add_argument('-x', '--excl-run', action='store_true', default=False,
                                   help='Terminate this job with `OVERLAP` status if another job in the same exclusion group '
                                        'is already running. The job ID is used as the default exclusion group.')
    concurrency_group.add_argument('--excl-group', type=str,
                                   help='Enables `--excl-run` and sets explicit exclusion group ID. Jobs with the same '
                                        'exclusion group cannot run simultaneously.')
    concurrency_group.add_argument('-s', '--serial', action='store_true', default=False,
                                   help='Run jobs one at a time. Jobs with same job ID or concurrent group ID wait in queue. '
                                        'Unlike --no-overlap, this puts job in waiting state instead of terminating it. '
                                        'Shortcut for --max-concurrent 1.')
    concurrency_group.add_argument('-m', '--max-concurrent', type=int, default=0,
                                   help='Limit concurrent executions. Jobs wait in queue when limit reached. '
                                        'Applies to jobs with same ID or concurrent group ID. Queue uses FIFO order.')
    concurrency_group.add_argument('-g', '--concurrency-group', type=str,
                                   help='Set concurrency group ID. Default: job ID. '
                                        'Used with --serial or --max-concurrent to limit concurrency across different jobs.')

    # Command and arguments
    job_parser.add_argument('command', type=str, metavar='COMMAND', help='Program to execute')
    job_parser.add_argument('arg', type=str, metavar='ARG', nargs=argparse.REMAINDER, help="Program arguments")


def _init_clean_parser(common, subparsers):
    """
    Creates parsers for `clean` command

    :param common: parent parser
    :param subparsers: sub-parser for clean parser to be added to
    """

    clean_parser = subparsers.add_parser(ACTION_CLEAN, parents=[common], description='Performs cleanups',
                                         add_help=False)


def _init_config_parser(subparser):
    """
    Creates parsers for `config` command and its subcommands.
    :param subparser: sub-parser for config parser to be added to
    """
    config_parser = subparser.add_parser(
        ACTION_CONFIG,
        description='Manage config file',
        help='Manage config file',
        formatter_class=RichHelpFormatter)

    config_subparser = config_parser.add_subparsers(dest='config_action', required=True)  # Actions under 'config'

    print_config_parser = config_subparser.add_parser(
        ACTION_CONFIG_PRINT,
        help='Print config file content',
        description='Print config file content. Default: prints loaded config from standard locations (e.g., XDG).',
        formatter_class=RichHelpFormatter)
    print_config_parser.add_argument(
        '-dc', '--def-config', action='store_true', help='Show default config file content.')

    create_config_parser = config_subparser.add_parser(
        ACTION_CONFIG_CREATE,
        help='Create new config file',
        description='Create new config file with defaults. Default location: standard user config dir (e.g., XDG_CONFIG_HOME).',
        formatter_class=RichHelpFormatter,
        add_help=True)
    create_config_parser.add_argument('-o', '--overwrite', action='store_true', help='Overwrite if config file exists.')
    create_config_parser.add_argument('-p', '--path', type=str, help='Specify path for created config file.')


# TODO Consider: change to str (like SortCriteria case) and remove this function
def _str2_term_status(v):
    try:
        return TerminationStatus[v.upper()]
    except KeyError:
        raise argparse.ArgumentTypeError('Arguments can be only valid execution states: '
                                         + ", ".join([e.name.lower() for e in TerminationStatus]))


def _duration_type(arg_value):
    try:
        return parse_duration_to_sec(arg_value)
    except ValueError as e:
        raise argparse.ArgumentTypeError(str(e))


def _check_conditions(parser, parsed):
    _check_config_option_conflicts(parser, parsed)


def _check_mutual_exclusion(parser, parsed, *option_names):
    """Check that at most one of the given options is present."""
    present = [opt for opt in option_names if getattr(parsed, opt.replace('-', '_'), None)]
    if len(present) > 1:
        cli_options = ['--' + opt.replace('_', '-') for opt in present]
        parser.error(f"Conflicting options: {' & '.join(cli_options)}")


def _check_config_option_conflicts(parser, parsed):
    """Check that invalid combinations of options were not used.

    Args:
        parser: The argument parser instance.
        parsed: The parsed arguments object.
    """
    _check_mutual_exclusion(parser, parsed, 'def_config', 'config_required', 'config')
    _check_mutual_exclusion(parser, parsed, 'bypass_output', 'log_output')
    _check_mutual_exclusion(parser, parsed, 'serial', 'max_concurrent')

    # Check dependent options
    if getattr(parsed, 'concurrency_group') and not (getattr(parsed, 'serial') or getattr(parsed, 'max_concurrent')):
        parser.error("`--concurrency-group` must be used with either `--serial` or `--max-concurrent`")
