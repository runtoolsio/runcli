import argparse
import re
import textwrap

import sys
from rich_argparse import RichHelpFormatter

from runtools.runcore.run import TerminationStatus
from . import __version__

ACTION_JOB = 'job'
ACTION_SERVICE = 'service'
ACTION_CLEAN = 'clean'
ACTION_CONFIG = 'config'
ACTION_CONFIG_PRINT = 'print'
ACTION_CONFIG_CREATE = 'create'


def parse_args(args):
    parser = argparse.ArgumentParser(
        prog='run',
        description='Run managed job or service',
        formatter_class=RichHelpFormatter)
    parser.add_argument(
        "-V",
        "--version",
        action='version',
        help="Show version of this app and exit",
        version=__version__.__version__)

    parent = init_cfg_parent_parser()
    subparser = parser.add_subparsers(dest='action')  # command/action

    _init_config_parser(subparser)
    _init_job_parser(parent, subparser)
    _init_clean_parser(parent, subparser)

    parsed = parser.parse_args(args)
    if not getattr(parsed, 'action', None):
        parser.print_help()
        sys.exit(1)

    _check_conditions(parser, parsed)
    return parsed


def init_cfg_parent_parser():
    """
    Return:
        Parent parser for subparsers to share common configuration options
    """
    parser = argparse.ArgumentParser()
    cfg_group = parser.add_argument_group("Configuration options")
    cfg_group.description = """
        These options control how configuration is loaded. By default, runtools  searches for its configuration file 
        in standard XDG directories and loads settings from the first found file. If no config is found 
        then default one is used. These options allow you to modify this default behavior.
    """
    cfg_group.add_argument('-dc', '--def-config', action='store_true',
                           help='Do not lookup config file and use default configuration instead.')
    cfg_group.add_argument('-cr', '--config-required', action='store_true',
                           help='Configuration file must be found, otherwise the command will fail. (No fallback)')
    cfg_group.add_argument('-C', '--config', type=str,
                           help="Specifies path to config file stored in custom location. Fails if the file doesn't exist.")
    cfg_group.add_argument('--set', type=str, action='append',
                           help='Override value of config attribute. Format: attribute=value. Example: log.stdout.level=info')
    return parser


def _init_job_parser(parent, subparser):
    """
    Creates parser for `job` command

    Args:
        parent: parent parser (config options)
        subparser: sub-parser for job parser to be added to
    """

    job_parser = subparser.add_parser(
        ACTION_JOB,
        parents=[parent],
        description='Execute managed batch or long-running job',
        help='Execute managed batch or long-running job',
        formatter_class=RichHelpFormatter,
        add_help=False)

    job_parser.description = textwrap.dedent("""
        Example of execution: run job --id my_job ./my_job.sh arg1 arg2
        
        Run job managed by runtools.
            
        It is recommended to use the `--id` option to specify the ID of the job otherwise the ID is constructed from the 
        command and its arguments. """)
    job_parser.add_argument('-e', '--env', type=str,
                            help="Environment ID where job will run. Uses default from config if not specified.")
    job_parser.add_argument('--id', type=str, metavar='JOB_ID',
                            help='Job ID. Identifies task type. Default: derived from command. '
                                 'Recommended to set explicitly.')
    job_parser.add_argument('--run-id', type=str,
                            help='Run ID. Identifies individual executions. Duplicates within same job are not allowed. '
                                 'Common values: UUID, date (2025-04-25), time, batch identifier (batch1), etc. '
                                 'Default: Autogenerated ID.')
    job_parser.add_argument('-b', '--bypass-output', action='store_true',
                            help='Disable output capturing. Program output goes directly to stdout/stderr. '
                                 'Improves compatibility with interactive programs using terminal control codes. '
                                 'Note: Disables output-based features like parsing and tracking.')
    job_parser.add_argument('-A', '--approve', metavar='PHASE_ID',
                            help='Adds approval phase with specified ID. Job waits in pending state until explicitly '
                                 'approved via API or CLI. ID is used to reference the approval for release commands.')
    job_parser.add_argument('-x', '--excl-run', action='store_true', default=False,
                            help='Terminate this job with `OVERLAP` status if another job in the same exclusion group '
                                 'is already running. The job ID is used as the default exclusion group.')
    job_parser.add_argument('--excl-group', type=str,
                            help='Enables `--excl-run` and sets explicit exclusion group ID. Jobs with the same '
                                 'exclusion group cannot run simultaneously.')
    job_parser.add_argument('-s', '--serial', action='store_true', default=False,
                            help='Run jobs one at a time. Jobs with same job ID or concurrent group ID wait in queue. '
                                 'Unlike --no-overlap, this puts job in waiting state instead of terminating it. '
                                 'Shortcut for --max-concurrent 1.')
    job_parser.add_argument('-m', '--max-concurrent', type=int, default=0,
                            help='Limit concurrent executions. Jobs wait in queue when limit reached. '
                                 'Applies to jobs with same ID or concurrent group ID. Queue uses FIFO order.')
    job_parser.add_argument('-g', '--concurrency-group', type=str,
                            help='Set concurrency group ID. Default: job ID. '
                                 'Used with --serial or --max-concurrent to limit concurrency across different jobs.')
    job_parser.add_argument('--warn-time', type=_warn_time_type, action='append', default=[],
                            help='This enables time warning which is trigger when the execution of the job exceeds '
                                 'the period specified by the value of this option. The value must be an integer '
                                 'followed by a single time unit character (one of [smhd]). For example `--warn-time '
                                 '1h` will trigger time warning when the job is executing over one hour.')
    job_parser.add_argument('--warn-output', type=str, action='append', default=[],
                            help='This enables output warning which is triggered each time an output line of the job '
                                 'matches regex specified by the value of this option. For example `--warn-output '
                                 '"ERR*"` triggers output warning each time an output line contains a word starting '
                                 'with ERR.')
    job_parser.add_argument('-d', '--depends-on', type=str, action='append', default=[],
                            help='The execution will be skipped if specified dependency job is not running.')
    job_parser.add_argument('-k', '--kv-filter', action='store_true', default=False,
                            help='Key-value output parser is used for task tracking.')
    job_parser.add_argument('--kv-alias', type=str, action='append', default=[],
                            help='Mapping of output keys to common fields.')
    job_parser.add_argument('-p', '--grok-pattern', type=str, action='append', default=[],
                            help='Grok pattern for extracting fields from output used for task tracking.')
    job_parser.add_argument('-t', '--timeout', type=str,
                            help='The value of this option specifies the signal number or code for stopping the job '
                                 'due to a timeout. A timeout warning is added to the job when it is stopped in this '
                                 'way.')

    job_parser.add_argument('--param', type=lambda p: p.split('='), action='append',
                            help="Parameters are specified in `name=value` format. They represent metadata of the "
                                 "job instance and have no effect on the job execution. They are stored for the each "
                                 "execution and can be retrieved later. For example the `history` command has "
                                 "`--show-params` option to display `Parameters` column.")
    # Terms command and arguments taken from python doc and docker run help,
    # for this app (or rather exec command) these are operands (alternatively arguments)
    job_parser.add_argument('command', type=str, metavar='COMMAND', help='Program to execute')
    job_parser.add_argument('arg', type=str, metavar='ARG', nargs=argparse.REMAINDER, help="Program arguments")


def _init_clean_parser(common, subparsers):
    """
    Creates parsers for `clean` command

    :param common: parent parser
    :param subparsers: sub-parser for clean parser to be added to
    """

    clean_parser = subparsers.add_parser(ACTION_CLEAN, parents=[common], description='Performs cleanups',
                                         add_help=False)


def _init_config_parser(subparser):
    """
    Creates parsers for `config` command and its subcommands.
    :param subparser: sub-parser for config parser to be added to
    """
    config_parser = subparser.add_parser(
        ACTION_CONFIG,
        description='Manage config file',
        help='Manage config file',
        formatter_class=RichHelpFormatter)

    config_subparser = config_parser.add_subparsers(dest='config_action', required=True) # Actions under 'config'

    print_config_parser = config_subparser.add_parser(
        ACTION_CONFIG_PRINT,
        help='Print config file content',
        description='Print config file content. Default: prints loaded config from standard locations (e.g., XDG).',
        formatter_class=RichHelpFormatter)
    print_config_parser.add_argument(
        '-dc', '--def-config', action='store_true', help='Show default config file content.')

    create_config_parser = config_subparser.add_parser(
        ACTION_CONFIG_CREATE,
        help='Create new config file',
        description='Create new config file with defaults. Default location: standard user config dir (e.g., XDG_CONFIG_HOME).',
        formatter_class=RichHelpFormatter,
        add_help=True)
    create_config_parser.add_argument('-o', '--overwrite', action='store_true', help='Overwrite if config file exists.')
    create_config_parser.add_argument('-p', '--path', type=str, help='Specify path for created config file.')

# TODO Consider: change to str (like SortCriteria case) and remove this function
def _str2_term_status(v):
    try:
        return TerminationStatus[v.upper()]
    except KeyError:
        raise argparse.ArgumentTypeError('Arguments can be only valid execution states: '
                                         + ", ".join([e.name.lower() for e in TerminationStatus]))


def _warn_time_type(arg_value):
    regex = r'^\d+[smhd]$'
    pattern = re.compile(regex)
    if not pattern.match(arg_value):
        raise argparse.ArgumentTypeError(f"Execution time warning value {arg_value} does not match pattern {regex}")
    return arg_value


def _check_conditions(parser, parsed):
    _check_config_option_conflicts(parser, parsed)


def _check_config_option_conflicts(parser, parsed):
    """Check that invalid combinations of options were not used.

    Args:
        parser: The argument parser instance.
        parsed: The parsed arguments object.
    """
    config_options = [opt for opt in ['def_config', 'config_required', 'config'] if getattr(parsed, opt)]
    concurrency_options = [opt for opt in ['serial', 'max_concurrent'] if getattr(parsed, opt)]

    for conflict_options in config_options, concurrency_options:
        if len(conflict_options) > 1:
            parser.error("Conflicting options: " + " & ".join(conflict_options))

    if getattr(parsed, 'concurrency_group') and not (getattr(parsed, 'serial') or getattr(parsed, 'max_concurrent')):
        parser.error("`--concurrency-group` must be used with either `--serial` or `--max-concurrent` > 0")
